# ============================================================
# Collaborative Messenger - 메인 설정 파일
# ============================================================
# 이 파일은 애플리케이션의 모든 설정을 한 곳에서 관리합니다.
# 각 섹션별로 무엇을 설정하는지 한글 주석으로 설명합니다.
# ============================================================

spring:
  application:
    name: collaborative-messenger    # 애플리케이션 이름 (로그, 모니터링에서 식별용)

  # ===== 파일 업로드 설정 =====
  servlet:
    multipart:
      max-file-size: 10MB          # 단일 파일 최대 크기
      max-request-size: 10MB       # 요청 전체 최대 크기

  # ===== JPA (데이터베이스 ORM) 설정 =====
  # JPA는 자바 객체(Entity)를 데이터베이스 테이블에 자동으로 매핑해주는 기술입니다.
  jpa:
    hibernate:
      ddl-auto: update               # 개발 중에는 update (엔티티 변경 시 테이블 자동 수정)
                                      # ★ 운영 환경에서는 반드시 'validate'로 변경할 것
    show-sql: true                    # 실행되는 SQL을 콘솔에 출력 (디버깅용)
    open-in-view: false               # ★ 샤딩 환경 필수! true면 하나의 DB 연결을 요청 내내 재사용하여
                                      #    ShardKeyHolder 변경이 반영되지 않음 (shard 교차 버그 발생)
    properties:
      hibernate:
        format_sql: true              # SQL을 보기 좋게 포맷팅
        default_batch_fetch_size: 100 # N+1 문제 방지: 연관 엔티티를 100개씩 한번에 로딩

  # ===== Redis 설정 =====
  # Redis는 메모리 기반 저장소로, 세션/캐시/접속상태 관리에 사용합니다.
  data:
    redis:
      host: localhost
      port: 6379
      password: redis1234

  # ===== Kafka 설정 =====
  # Kafka는 대용량 메시지 처리를 위한 분산 메시지 브로커입니다.
  # 채팅 메시지가 WebSocket으로 들어오면 → Kafka에 발행 → Consumer가 소비하여 DB 저장 + 브로드캐스트
  kafka:
    bootstrap-servers: localhost:9092  # Kafka 브로커 주소
    consumer:
      group-id: messenger-chat-group  # 컨슈머 그룹 (같은 그룹의 컨슈머끼리 파티션을 나눠 처리)
      auto-offset-reset: earliest     # 처음 연결 시 가장 오래된 메시지부터 읽기
      # ★ Key/Value 모두 String 직렬화 (KafkaConfig.java에서 설정)
      # JSON 변환은 Producer/Consumer 코드에서 ObjectMapper로 직접 처리
    producer: {}

  # ===== Thymeleaf 템플릿 엔진 설정 =====
  thymeleaf:
    cache: false                      # 개발 중에는 캐시 끄기 (HTML 수정 시 즉시 반영)
    prefix: classpath:/templates/     # HTML 파일 위치
    suffix: .html

  # ===== 세션 설정 (Redis에 저장) =====
  # 사용자 로그인 세션을 Redis에 저장하면, 서버를 재시작해도 로그인 유지됩니다.
  session:
    store-type: redis
    timeout: 30m                      # 세션 만료 시간: 30분 동안 활동이 없으면 자동 로그아웃

# ===== MySQL 샤딩 DataSource (커스텀 설정) =====
# Spring 기본 datasource 대신, 우리가 직접 2개의 MySQL을 관리합니다.
# shard_0: 모든 테이블 + 짝수 chatRoomId의 메시지
# shard_1: 홀수 chatRoomId의 메시지만 저장
datasource:
  shard0:
    url: jdbc:mysql://localhost:3307/messenger_shard_0?useSSL=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&allowPublicKeyRetrieval=true
    username: messenger
    password: messenger1234
    driver-class-name: com.mysql.cj.jdbc.Driver
  shard1:
    url: jdbc:mysql://localhost:3308/messenger_shard_1?useSSL=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&allowPublicKeyRetrieval=true
    username: messenger
    password: messenger1234
    driver-class-name: com.mysql.cj.jdbc.Driver

# ===== 업무일지 자동 생성 설정 =====
report:
  generation:
    cron: "0 0 18 * * MON-FRI"       # 월~금 오후 6시에 자동 생성
    enabled: true                      # true면 스케줄 활성화, false면 비활성화

# ===== 로깅 설정 =====
# 로그 포맷에 traceId와 userId를 포함시켜 특정 요청의 전체 흐름을 추적할 수 있습니다.
# 예시: 14:30:25.123 [http-nio-8080-exec-1] [traceId=a1b2c3d4] [user=42] DEBUG ChatService - 메시지 저장 완료
logging:
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] [traceId=%X{traceId}] [user=%X{userId}] %-5level %logger{36} - %msg%n"
  level:
    com.messenger: DEBUG                          # 우리 코드는 DEBUG 레벨로 상세 출력
    com.messenger.infrastructure.sharding: DEBUG  # 샤딩 라우팅 로그 (어떤 샤드로 가는지)
    com.messenger.infrastructure.kafka: DEBUG     # Kafka 메시지 발행/소비 로그
    org.springframework.web.socket: INFO          # WebSocket 연결 로그
    org.hibernate.SQL: DEBUG                      # Hibernate가 실행하는 SQL 출력
    org.hibernate.type.descriptor.sql: TRACE      # SQL 파라미터 바인딩 값 출력

# ===== 서버 설정 =====
server:
  port: 8888
  servlet:
    session:
      cookie:
        http-only: true               # JavaScript에서 쿠키 접근 차단 (보안)
        secure: false                  # 개발 중에는 false (HTTPS가 아니므로)
